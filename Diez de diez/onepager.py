# -*- coding: utf-8 -*-
"""OnePager.ipynb

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/1Co8Op1TihyUSAX5Eq4buHeHzO19j0Hm4
"""
!pip install joblib
import streamlit as st
import pandas as pd
import matplotlib.pyplot as plt
import folium
from folium import CircleMarker
from streamlit_folium import st_folium
from branca.colormap import LinearColormap
import joblib
import numpy as np
from sklearn.metrics import classification_report, confusion_matrix
import seaborn as sns
import matplotlib.pyplot as plt

st.title("OXXO: Descubriendo las Tiendas del Futuro ")

df = pd.read_csv("df_binary_train.csv")
df_numeric = pd.read_csv("df_train_numeric.csv")

st.header("Ubicación Geográfica de las Tiendas")
st.markdown("""
Este mapa muestra la distribución actual de tiendas. Observamos mayor concentración en zonas urbanas  con las zonas con mayor concentración tienden a ser de nivel socioeconómico **C**, mientras que las zonas tipo **A** presentan una menor cobertura.

Esto sugiere una oportunidad de expansión en zonas donde la cobertura es baja.
""")
mexico_map = folium.Map(location=[25.0, -101.5], zoom_start=7)
color_mapping = {
    'A': 'darkgreen',
    'AB': 'green',
    'B': 'lime',
    'BC': 'lightgreen',
    'C': 'yellow',
    'CD': 'orange',
    'D': 'red'
}

for lat, lng, nivel in zip(df['LATITUD_NUM'], df['LONGITUD_NUM'], df['NIVELSOCIOECONOMICO_DES']):
    color = color_mapping.get(nivel, '#808080')
    folium.CircleMarker(
        location=[lat, lng],
        radius=5,
        color=color,
        fill=True,
        fill_color=color,
        fill_opacity=0.7,
        popup=f"Nivel: {nivel}"
    ).add_to(mexico_map)


legend_html = '''
<div style="
    position: fixed;
    bottom: 10px;
    left: 10px;
    width: 110px;
    border: 1px solid grey;
    z-index: 9999;
    font-size: 10px;
    background-color: white;
    padding: 5px;
    line-height: 1.3;
    ">
    <div style="font-weight: bold; text-align: center; margin-bottom: 3px;">Socioeconomic Level</div>
    <div style="display: flex; align-items: center; margin: 1px 0;">
        <div style="width: 12px; height: 12px; background-color: darkgreen; margin-right: 5px;"></div>
        <span>A</span>
    </div>
    <div style="display: flex; align-items: center; margin: 1px 0;">
        <div style="width: 12px; height: 12px; background-color: green; margin-right: 5px;"></div>
        <span>AB</span>
    </div>
    <div style="width: 12px; height: 12px; background-color: lime; margin-right: 5px;"></div>
        <span>B</span>
    <div style="width: 12px; height: 12px; background-color: lightgreen; margin-right: 5px;"></div>
        <span>BC</span>
    <div style="width: 12px; height: 12px; background-color: yellow; margin-right: 5px;"></div>
        <span>C</span>
    <div style="width: 12px; height: 12px; background-color: orange; margin-right: 5px;"></div>
        <span>CD</span>
    <div style="width: 12px; height: 12px; background-color: red; margin-right: 5px;"></div>
        <span>D</span>
</div>
'''
mexico_map.get_root().html.add_child(folium.Element(legend_html))

st_data = st_folium(mexico_map, width=700, height=500)

st.header("Número de Tiendas por Nivel Socioeconómico")
st.markdown("""
""")
plt.figure(figsize=(8, 5))
sns.countplot(data=df, x='NIVELSOCIOECONOMICO_DES', order=df['NIVELSOCIOECONOMICO_DES'].value_counts().index, palette="viridis")
plt.title("Número de Tiendas por Nivel Socioeconómico")
plt.xlabel("Nivel Socioeconómico")
plt.ylabel("Número de Tiendas")
plt.xticks(rotation=45)
plt.tight_layout()
plt.show()


count_by_nse = df['NIVELSOCIOECONOMICO_DES'].value_counts().sort_index()
print(count_by_nse)


st.header("Mapa Binario de Éxito por Tienda")

color_mapping = {1: 'green', 0: 'red'}
mapa_exito = folium.Map(location=[25.0, -101.5], zoom_start=6)

for lat, lng, exito in zip(df['LATITUD_NUM'], df['LONGITUD_NUM'], df['labelExito']):
    folium.CircleMarker(
        location=[lat, lng],
        radius=5,
        color=color_mapping.get(exito, 'gray'),
        fill=True,
        fill_color=color_mapping.get(exito, 'gray'),
        fill_opacity=0.7,
        popup=f"Éxito: {exito}"
    ).add_to(mapa_exito)

# Agregar leyenda manualmente
legend_html = '''
<div style="
    position: fixed;
    bottom: 10px;
    left: 10px;
    width: 110px;
    border: 1px solid grey;
    z-index: 9999;
    font-size: 10px;
    background-color: white;
    padding: 5px;
    line-height: 1.3;
    ">
    <div style="font-weight: bold; text-align: center; margin-bottom: 3px;">Socioeconomic Level</div>
    <div style="display: flex; align-items: center; margin: 1px 0;">
        <div style="width: 12px; height: 12px; background-color: darkgreen; margin-right: 5px;"></div>
        <span>A</span>
    </div>
    <div style="display: flex; align-items: center; margin: 1px 0;">
        <div style="width: 12px; height: 12px; background-color: green; margin-right: 5px;"></div>
        <span>AB</span>
    </div>
    <div style="display: flex; align-items: center; margin: 1px 0;">
        <div style="width: 12px; height: 12px; background-color: lime; margin-right: 5px;"></div>
        <span>B</span>
    </div>
    <div style="display: flex; align-items: center; margin: 1px 0;">
        <div style="width: 12px; height: 12px; background-color: lightgreen; margin-right: 5px;"></div>
        <span>BC</span>
    </div>
    <div style="display: flex; align-items: center; margin: 1px 0;">
        <div style="width: 12px; height: 12px; background-color: yellow; margin-right: 5px;"></div>
        <span>C</span>
    </div>
    <div style="display: flex; align-items: center; margin: 1px 0;">
        <div style="width: 12px; height: 12px; background-color: orange; margin-right: 5px;"></div>
        <span>CD</span>
    </div>
    <div style="display: flex; align-items: center; margin: 1px 0;">
        <div style="width: 12px; height: 12px; background-color: blue; margin-right: 5px;"></div>
        <span>D</span>
    </div>
</div>
'''
mexico_map.get_root().html.add_child(folium.Element(legend_html))

st_folium(mapa_exito, width=700)

#-----
st.header("Relación entre Entorno y Nivel Socioeconómico")

st.markdown("""
Este mapa de calor muestra cómo se distribuyen los entornos con respecto a los niveles socioeconómicos. 
Nos ayuda a identificar combinaciones comunes y posibles desequilibrios.
""")

contingency_table_1 = pd.crosstab(df["ENTORNO_DES"], df["NIVELSOCIOECONOMICO_DES"])
fig1, ax1 = plt.subplots(figsize=(8, 5))
sns.heatmap(contingency_table_1, annot=True, fmt='d', cmap="YlGnBu", ax=ax1)
ax1.set_title("Entorno vs Nivel Socioeconómico")
ax1.set_xlabel("Nivel Socioeconómico")
ax1.set_ylabel("Entorno")
st.pyplot(fig1)


st.header("Relación entre Entorno y Segmento Maestro")

st.markdown("""
Este mapa de calor muestra cómo se relacionan los entornos con los diferentes segmentos de tienda.
""")

contingency_table_2 = pd.crosstab(df["ENTORNO_DES"], df["SEGMENTO_MAESTRO_DESC"])
fig2, ax2 = plt.subplots(figsize=(8, 5))
sns.heatmap(contingency_table_2, annot=True, fmt='d', cmap="YlGnBu", ax=ax2)
ax2.set_title("Entorno vs Segmento Maestro")
ax2.set_xlabel("Segmento")
ax2.set_ylabel("Entorno")
st.pyplot(fig2)


st.header("Distribución de Metros Cuadrados por Entorno")

st.markdown("""
El siguiente boxplot nos permite visualizar la distribución de metros cuadrados de tiendas dentro de cada entorno. 
Esto puede indicar diferencias en tamaño promedio de las tiendas dependiendo del contexto.
""")

fig3, ax3 = plt.subplots(figsize=(10, 6))
sns.boxplot(data=df, x="ENTORNO_DES", y="MTS2VENTAS_NUM", palette="Set3", ax=ax3)
ax3.set_title("Distribución de Metros Cuadrados por Entorno")
ax3.set_xlabel("Entorno")
ax3.set_ylabel("Metros Cuadrados")
ax3.tick_params(axis='x', rotation=45)
st.pyplot(fig3)


st.header("Frecuencia de Tiendas por Entorno")

st.markdown("""
La gráfica siguiente muestra cuántas tiendas hay por entorno. Nos permite ver en qué tipo de entorno hay más presencia.
""")

fig4, ax4 = plt.subplots()
sns.countplot(data=df, x="ENTORNO_DES", order=df["ENTORNO_DES"].value_counts().index, ax=ax4)
ax4.set_title("Frecuencia de cada entorno")
ax4.tick_params(axis='x', rotation=45)
st.pyplot(fig4)
#-----
st.header("🧠 Predicción de Éxito en Tiendas")

# 📦 Cargar modelo
@st.cache_resource
def load_model():
    return joblib.load('modelo/decision_tree_pipeline.joblib')

model = load_model()

# 📁 Cargar test set
@st.cache_data
def load_test_data():
    df = pd.read_csv('test_set.csv')
    y = df['labelExito']
    X = df.drop(columns='labelExito')
    return X, y

X_test, y_test = load_test_data()

# 📊 Evaluación
st.header("📊 Evaluación del Modelo")

umbral = st.slider("Ajustar umbral de decisión", 0.0, 1.0, 0.3, 0.01)
probs = model.predict_proba(X_test)[:, 1]
y_pred = (probs > umbral).astype(int)

report = classification_report(y_test, y_pred, output_dict=True)
df_report = pd.DataFrame(report).transpose()

st.subheader("Reporte de Clasificación")
st.dataframe(df_report.style.format("{:.2f}"))

# 🎯 Matriz de confusión
st.subheader("Matriz de Confusión")
cm = confusion_matrix(y_test, y_pred)
tn, fp, fn, tp = cm.ravel()
st.write(f"*Falsos Positivos (FP): {fp}  |  **Falsos Negativos (FN)*: {fn}")
fig, ax = plt.subplots()
sns.heatmap(cm, annot=True, fmt='d', cmap='Blues',
            xticklabels=['No éxito','Éxito'],
            yticklabels=['No éxito','Éxito'],
            ax=ax)
ax.set_xlabel("Predicción")
ax.set_ylabel("Real")
st.pyplot(fig)

# 🧪 Predicción manual
st.header("🧪 Predicción con Nuevos Datos")

with st.form("form_pred"):
    col1, col2 = st.columns(2)

    with col1:
        entorno = st.selectbox("ENTORNO_DES", ['URBANO', 'RURAL'])
        nivel_socio = st.selectbox("NIVELSOCIOECONOMICO_DES", ['1', '2', '3', '4'])
        ubicacion = st.selectbox("LID_UBICACION_TIENDA", ['A', 'B', 'C', 'D'])
        segmento = st.selectbox("SEGMENTO_MAESTRO_DESC", ['SUPERMERCADO', 'MINIMARKET', 'OTRO'])

    with col2:
        mts2ventas = st.number_input("MTS2VENTAS_NUM", min_value=0)
        puertas = st.number_input("PUERTASREFRIG_NUM", min_value=0)
        competencia = st.number_input("COMPETENCIA_500", min_value=0)

    submitted = st.form_submit_button("Predecir")

    if submitted:
        input_data = pd.DataFrame([{
            'ENTORNO_DES': entorno,
            'NIVELSOCIOECONOMICO_DES': nivel_socio,
            'LID_UBICACION_TIENDA': ubicacion,
            'SEGMENTO_MAESTRO_DESC': segmento,
            'MTS2VENTAS_NUM': mts2ventas,
            'PUERTASREFRIG_NUM': puertas,
            'COMPETENCIA_500': competencia,
        }])

        prob = model.predict_proba(input_data)[0,1]
        pred = "✅ Éxito" if prob > umbral else "❌ No Éxito"
        st.metric("Probabilidad de Éxito", f"{prob:.1%}")
        st.subheader(f"Resultado: {pred}")


